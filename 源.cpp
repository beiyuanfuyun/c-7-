#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<string>
using namespace std;
//-----------07继承-------------
//01.继承与派生――――多继承--多派生--多级继承（祖父传父--父传子）
//02.继承方式
//**03.继承之后的析构构造
//04.菱形继承


//---------------01---------------
//继承与派生是同一个东西
// 1.继承是一种创建类的方式，新建的类可以继承一个或者多个类
// 2.所以继承描述的是类和类的关系
// 3.新建的类被称之为  派生类（子类），之前就存在的类被称作为基类（父类）

//------------------------02看附件------------------
//1.公有继承
// 2.私有继承
// 3.保护继承，所以这个是最好的，既可以正常访问又可以保护

//------------03----------------------
//1.派生类会继承除基类的 构造析构函数 之外的所有成员变量和成员函数
// 2.可以在派生类中添加新的成员，通过派生类对象调用，但是基类访问不到新加的成员
//3.如果派生类中添加的成员名和基类型的成员名相同，那么派生类会隐藏基类的成员，如果想访问隐藏的基类的成员，可以使用作用域来访问  father::a;

//--------------------04-------------------------
//会出现问题看下面
//
//


//-----------------01-----------------------
//class father
//{
//public:
//	int a = 0;
//	int b = 1;
//	int c = 2;
//	void show()
//	{
//		cout << a << endl;
//		cout << b << endl;
//		cout << c << endl;
//	}
//};
//
//class mother
//{
//public:
//	int d = 19;
//};
////类  默认 私有  私有继承-加上共有属性  
////  class 子类类名 ： 继承方式  父类类名
//class child: public father//如果还有其他的父类和初始化成员列表相同用逗号（,）隔开
//{
//	//空的
//public:
//	void fun()
//	{
//		this->a;//自己的
//		//father::a;//虽然可以，但容易出问题
//	}
//
//};


//-----------------------------03------------------------
//class A
//{
//public:
//	int a = 1;
//	A()
//	{
//		cout << "A的构造" << endl;
//	}
//	~A()
//	{
//		cout << "A的析构" << endl;
//	}
//};
//class B:public A
//{
//public:
//	int a = 2;
//	B()
//	{
//		cout << "B的构造" << endl;
//	}
//	~B()
//	{
//		cout << "B的析构" << endl;
//	}
//};
//class C :public B
//{
//public:
//	int a = 3;
//	C()
//	{
//		cout << "C的构造" << endl;
//	}
//	~C()
//	{
//		cout << "C的析构" << endl;
//	}
//};
//-----------03额外构造与析构的调用顺序以及相关构造的细节问题---------------------------
//class A
//{
//public:
//	int a = 1;
//	A()
//	{
//		cout << "A的构造" << endl;
//	}
//	~A()
//	{
//		cout << "A的析构" << endl;
//	}
//};
//
//class C
//{
//public:
//	int a = 3;
//	C()
//	{
//		cout << "C的构造" << endl;
//	}
//	~C()
//	{
//		cout << "C的析构" << endl;
//	}
//};
//
//class B :public A
//{
//public:
//	C c;
//	int a = 2;
//	B()
//	{
//		cout << "B的构造" << endl;
//	}
//	~B()
//	{
//		cout << "B的析构" << endl;
//	}
//};
//细节：在写继承的时候，要确保基类有可以调用的构造函数
//eg:
//class A
//{
//public:
//	int a ;
//	A(int val)//A当中仅有带参构造
//	{
//		a = val;
//	}
//	~A()
//	{
//
//	}
//};
//class B:public A
//{
//	int b = 2;
//	B() :A(1)//对B()的构造传参//A当中仅有带参构造--子类初始化成员列表中构造
//	{
//
//	}
//};

//class C//构造时初始化复习
//{
//public:
//	int a;
//	int number;
//	C();
//	C(int cal);
//};
//C::C() :a(100), number(20) {}

    /*class A
	{
	public:
		int a = 1;
	};
	class B: virtual public A
	{
	public:
		int b = 2;
	};
	class C : virtual public A
	{
	public:
		int c = 3;
	};
	class D:public B,public C
	{
	public:
		int d = 4;
	};*/



int main()
{
	//-----------01---------------------
	//father a;
	//a.show();
	//child c;
	//c.show();


	//-------------------03-------------------------
	//cout << sizeof(A) << endl;//4
	//cout << sizeof(B) << endl;//8//继承了A，说隐藏只是标识符没写，但在内存底盘还是存在
	//B b;
	//cout << &b << endl;//父类的数据优先放在内存前面
	
	//C c;
	//cout << &c << endl;
	//C c;//多级继承以及多继承都和顺序有关，和栈的结构很像

	//B b = c;//基类对象=子类对象   可以  子类里面的成员包含b的所有成员，所有可以对 b 中的成员复制，
	// 被修改的数，就用修改值，虽然隐藏的值还在且没变，就像全局变量和局部变量一样，其他的又是背照搬回去（但是新增的不给b）
	//c = b;  //不行    子类>基类
	//--------------03额外细节-------------------------
	//B b;//第一个细节构造和析构顺序
	//
	//B b;//报错   第二个细节继承 构造的前提，继承的基函数中要有可调用的构造，那怎么解决呢？看上面
	//B b;
	

//-------------------04-------------------------------
	//D d;
	//cout << sizeof(A) << endl;
	//cout << sizeof(B) << endl;
	//cout << sizeof(C) << endl;
	//cout << sizeof(D)<<endl;//20，会重复的a内存，内存底盘的数据会出现问题，
	////怎么解决呢？利用虚继承――关键字virtual,更新之后的内存为48(可能是因为编译器的不同我这个我为48但是老师的为24)，加入了两个指针，其中的一个指针代替了重复的A的片段，另一个就是多加的
	////且这两个指针指向A，反正虚继承可以解决隐患，至于内存为什么会这样我还不知道，但是虚继承会发生类之前，也就是B与C早已经改变了
	//cout << &d << endl;
	//cout << sizeof(B) <<endl<< sizeof(C) << endl;
	return 0;
}